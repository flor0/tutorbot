spring.application.name=TutorBot
spring.config.import=file:.env[.properties]

langchain4j.google-ai-gemini.chat-model.api-key=${GEMINI_API_KEY}
langchain4j.google-ai-gemini.chat-model.model-name=gemini-2.0-flash
langchain4j.google-ai-gemini.chat-model.max-output-tokens=100
langchain4j.google-ai-gemini.chat-model.log-requests-and-responses=true


# Postgres datasource (used for storing users/auth)
spring.datasource.url=jdbc:postgresql://${POSTGRES_HOST:localhost}:${POSTGRES_PORT:5432}/${POSTGRES_DB:lecturevault}
spring.datasource.username=${POSTGRES_USER:postgres}
spring.datasource.password=${POSTGRES_PASSWORD:secret}

spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true
spring.jpa.properties.hibernate.format_sql=false

# If you want to use Docker Compose integration in Spring Boot during tests/dev,
# you can set spring-boot-docker-compose or related properties. Not required here.

# MongoDB (from compose.yaml)
# Docker Compose exposes mongo on localhost:27017 with credentials set in compose.yaml.
# Use env vars to allow overriding when running in different environments.
spring.data.mongodb.uri=mongodb://${MONGO_INITDB_ROOT_USERNAME:root}:${MONGO_INITDB_ROOT_PASSWORD:secret}@${MONGO_HOST:localhost}:${MONGO_PORT:27017}/${MONGO_INITDB_DATABASE:mydatabase}?authSource=admin
spring.data.mongodb.database=${MONGO_INITDB_DATABASE:mydatabase}

spring.servlet.multipart.max-file-size=50MB
